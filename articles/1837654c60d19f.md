---
title: "Grid ã§ã‚‚æ€è€ƒåœæ­¢ã§ Union Find ãŒã—ãŸã„ï¼"
emoji: "ğŸŒ²"
type: "tech"
topics: ["atcoder", "cpp", "unionfind", "ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ "]
published: true
---

## ã¯ã˜ã‚ã«
Gridã€ã¤ã¾ã‚Šã¯äºŒæ¬¡å…ƒã®ã‚°ãƒ©ãƒ•ã«ã¤ã„ã¦ã®é€£çµåˆ¤å®šã‚’ã—ãŸã„ã¨ãã£ã¦ã‚ã‚Šã¾ã™ã‚ˆã­ã€‚ã“ã®ã¨ãã« DFS / BFS ã‚’ã‚µãƒ©ãƒƒã¨ã‹ã‘ã‚Œã°ã„ã„ã‚“ã§ã™ãŒã€å®Ÿè£…åŠ›ãŒãªã„ãŸã‚ã€ã‚°ãƒ€ã‚°ãƒ€ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

ã“ã†ã„ã†ã¨ãã«å½¹ç«‹ã¤ï¼ˆæ€è€ƒåœæ­¢ã§ snippet ã‚’è²¼ã‚Œã‚‹ï¼‰`pair<int, int>` ã‚’ç´ é›†åˆã¨ã—ã¦æ‰±ãˆã‚‹ Union Find (Disjoint Set Union) ã‚’æ›¸ã„ã¦ã¿ã¾ã—ãŸï¼ˆC++ ã§é¡ä¼¼ã®è¨˜äº‹[^1]ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã“ã®è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ã¾ã™ï¼‰

## å®Ÿè£…
çµŒè·¯åœ§ç¸® (Path halving) ã¨ Union by size ã§å®Ÿè£…[^2]ã—ã¦ã„ã¾ã™ã€‚

:::message alert
æ™®é€šã® vector ã‚’ç”¨ã„ãŸ Union Find ãªã‚‰ã°ã€vector ã®å€¤ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã®è¨ˆç®—é‡ã¯ $O(1)$ ã§ã‚ã‚‹ãŸã‚ã€è¨ˆç®—é‡ãŒ $O(\alpha(N))$ ã«ãªã‚Šã¾ã™ã€‚($\alpha(N)$ ã¯ã‚¢ãƒƒã‚«ãƒ¼ãƒãƒ³é–¢æ•°ã®é€†é–¢æ•°) 

ã—ã‹ã—ã€map ã®å€¤ã®ã‚¢ã‚¯ã‚»ã‚¹ã®è¨ˆç®—é‡ã¯ $O(\log N)$ ã§ã‚ã‚‹ã‹ã‚‰ã€ã“ã® pair ã‚’æŒãŸã›ã‚‰ã‚Œã‚‹ Union Find ã®è¨ˆç®—é‡ã¯ $O(\alpha (N) \log N)$ ã§ã™ã€‚ï¼ˆã“ã“ã‚‰ã¸ã‚“ã¯æ€ªã—ã„ã®ã§ã€æŒ‡æ‘˜ã®ã»ã©ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ï¼‰
:::

åˆæœŸåŒ–ã«ã‹ã‹ã‚‹è¨ˆç®—é‡ã¯ $O(HW)$ ã§ã‚ã‚‹ãŸã‚ $HW \leq 10^6$ ç¨‹åº¦ã§ãªã„ã¨å±ãªãã†ã§ã™ã€‚

| æ©Ÿèƒ½ | èª¬æ˜ |
| ---- | ---- |
| `.root(x)` | x ã‚’å«ã‚€é›†åˆã®ä»£è¡¨ã‚’è¿”ã™ |
| `.merge(x, y)` | x ã‚’å«ã‚€é›†åˆã¨ y ã‚’å«ã‚€é›†åˆã®ä½µåˆã‚’è¡Œã† |
| `.same(x, y)`| x ã¨ y ãŒåŒã˜é›†åˆã«å±ã™ã‚‹ã‹åˆ¤å®šã™ã‚‹ |
| `.size(x)`| x ã‚’å«ã‚€é›†åˆã®è¦ç´ æ•°ã‚’è¿”ã™ | 

:::details Code
https://github.com/Kyure-A/competitive-snippets/blob/master/kyre/PairedUnionFind.hpp
:::

## ä¾‹é¡Œ

### [ABC 300 C - Cross](https://atcoder.jp/contests/abc300/tasks/abc300_c)
:::details Code

``` c++
class PairedUnionFind
{
public:
  map<pair<int, int>, pair<int, int>> parent;
  map<pair<int, int>, int> set_size;
 
  // constructor
  PairedUnionFind (int h, int w): parent(), set_size()
  {
    for (int i = 0; i < h; ++i)
      {
	for (int j = 0; j < w; ++j)
	  {
	    parent[{i, j}] = {i, j};
	    set_size[{i, j}] = 1;
	  }
      }
  }
 
  pair<int, int> root (pair<int, int> x) // find (path halving)
  {
    while (parent[x] != x)
      {
	parent[x] = parent[parent[x]];
	x = parent[x];
      }
 
    return x;
  }
 
  bool merge (pair<int, int> x, pair<int, int> y) // union by size
  {
    pair<int, int> rx = root(x);
    pair<int, int> ry = root(y);
 
    if (rx == ry) return false;
    else if (set_size[rx] < set_size[ry]) swap(rx, ry); // root(y) ã®ã»ã†ãŒãƒ‡ã‚«ã„ã¨ãã‚‚ merge ã§ãã‚‹ã‚ˆã†ã«é€†ã«ã™ã‚‹
    
    // Operations
    parent[ry] = rx;
    set_size[rx] += set_size[ry];
    return true;
  }
 
  bool same (pair<int, int> x, pair<int, int> y)
  {
    return root(x) == root(y);
  }
 
  int size(pair<int, int> x)
  {
    return set_size[root(x)];
  }
 
};
 
signed main ()
{
  cin.tie(nullptr);
  ios_base::sync_with_stdio(false);
 
  int h, w; cin >> h >> w;
  vector<vector<char>> c(h, vector<char>(w)); rep(i, h) rep(j, w) cin >> c[i][j];
  PairedUnionFind tree(h, w);
  
  // init
  for (int i = 0; i < h; ++i)
    {
      for (int j = 0; j < w; ++j)
	{
	  if (c[i][j] == '#' and i + 1 < h and j + 1 < w)
	    {
	      if (c[i + 1][j + 1] == '#') tree.merge({i, j}, {i + 1, j + 1});
	    }
 
	  if (c[i][j] == '#' and i + 1 < h and j - 1 >= 0)
	    {
	      if (c[i + 1][j - 1] == '#') tree.merge({i, j}, {i + 1, j - 1});
	    }
 
	      if (c[i][j] == '#' and i - 1 >= 0 and j + 1 < h)
	    {
	      if (c[i - 1][j + 1] == '#') tree.merge({i, j}, {i - 1, j + 1});
	    }
 
	      if (c[i][j] == '#' and i - 1 >= 0 and j - 1 >= 0)
	    {
	      if (c[i - 1][j - 1] == '#') tree.merge({i, j}, {i - 1, j - 1});
	    }
	}
    }
 
  // solve
  set<pair<int, int>> cross;
  
  for (int i = 0; i < h; ++i)
    {
      for (int j = 0; j < w; ++j)
	{
	  bool is_same = false;
	  
	  for (auto x : cross)
	    {
	      if (tree.same({i, j}, x))
		{
		  is_same = true;
		  break;
		}
	    }
 
	  if (is_same or tree.size({i, j}) == 1) continue; // "." ã®é›†åˆã‚’é™¤ã
	  
	  cross.insert({i, j});
	}
    }
  
  int n = min(h, w);
  vector<int> answer(n + 1, 0);
 
  for (auto x : cross)
    {
      int size = tree.size(x) / 4; // floor
      answer[size]++;
    }
 
  for (int i = 1; i <= n; ++i)
    {
      cout << answer[i] << " ";
    }
 
  cout << endl;
 
  return 0;
}
```
:::

### [ç«¶ãƒ—ãƒ­å…¸å‹ 90 å• 012 - Red Painting (â˜…4)](https://atcoder.jp/contests/typical90/tasks/typical90_l)
:::details Code

``` c++
class PairedUnionFind
{
public:
  map<pair<int, int>, pair<int, int>> parent;
  map<pair<int, int>, int> set_size;
 
  // constructor
  PairedUnionFind (int h, int w): parent(), set_size()
  {
    for (int i = 0; i < h; ++i)
      {
	for (int j = 0; j < w; ++j)
	  {
	    parent[{i, j}] = {i, j};
	    set_size[{i, j}] = 1;
	  }
      }
  }
 
  pair<int, int> root (pair<int, int> x) // find (path halving)
  {
    while (parent[x] != x)
      {
	parent[x] = parent[parent[x]];
	x = parent[x];
      }
 
    return x;
  }
 
  bool merge (pair<int, int> x, pair<int, int> y) // union by size
  {
    pair<int, int> rx = root(x);
    pair<int, int> ry = root(y);
 
    if (rx == ry) return false;
    
    // Operations
    else if (set_size[rx] < set_size[ry])
      {
	parent[rx] = ry;
	set_size[ry] += set_size[rx];
      }
    else
      {
	parent[ry] = rx;
	set_size[rx] += set_size[ry];
      }
    
    return true;
  }
 
  bool same (pair<int, int> x, pair<int, int> y)
  {
    return root(x) == root(y);
  }
 
  int size(pair<int, int> x)
  {
    return set_size[root(x)];
  }
 
};
 
signed main ()
{
  cin.tie(nullptr);
  ios_base::sync_with_stdio(false);
 
  int h, w; cin >> h >> w;
  int q; cin >> q;
  
  PairedUnionFind tree(h + 1, w + 1); // 1 indexed
 
  map<pair<int, int>, bool> is_painted;
 
  constexpr int dx[4] = {1, 0, -1, 0};
  constexpr int dy[4] = {0, 1, 0, -1};
  
  while (q--)
    {
      int query; cin >> query;
 
      if (query == 1)
	{
	  int r, c; cin >> r >> c;
	  is_painted[{r, c}] = true;
 
	  for (int i = 0; i < 4; ++i)
	    {
	      int nx = r + dx[i];
	      int ny = c + dy[i];
		  
	      if (1 <= nx and nx <= h and 1 <= ny and ny <= w) // 1 indexed
		{
		  if (is_painted[{nx, ny}]) tree.merge({r, c}, {nx, ny});
		}
	    }
	}
 
      if (query == 2)
	{
	  int r_a, c_a, r_b, c_b; cin >> r_a >> c_a >> r_b >> c_b;
 
	  if (r_a == r_b and c_a == c_b and is_painted[{r_a, c_a}])
	    {
	      cout << "Yes" << endl;
	    }
	  
	  else if ((r_a != r_b or c_a != c_b) and tree.same({r_a, c_a}, {r_b, c_b}))
	    {
	      cout << "Yes" << endl;
	    }
	  
	  else cout << "No" << endl;
	}
    }
  
  return 0;
}
```

:::

[^1]: Python ã§ map ã« ID ã‚’æŒ¯ã‚‹ã“ã¨ã§å®Ÿè£…ã—ãŸä¾‹ãŒã‚ã‚Šã¾ã—ãŸã€‚å†·é™ã«è€ƒãˆã‚‹ã¨ã“ã®è¨˜äº‹ã«ã‚ã‚‹ Union Find ã® `pair<int, int>` ã®ã¿ã‚’æ‰±ãˆã‚‹ä¸‹ä½äº’æ›ã§ã™ã­ã€‚
https://qiita.com/tomato1997/items/7c001c2a9a1e7f428241
[^2]: ã“ã‚Œã¯æ—¢å­˜ã® Union Find ã‚’ `pair<int, int>` ã«æ›¸ãæ›ãˆãŸã‚‚ã®ãªã®ã§ã™ãŒã€é€šå¸¸ã® Union Find ã‚’å®Ÿè£…ã™ã‚‹éš›ã«å‚è€ƒã«ã—ãŸè¨˜äº‹ã§ã™ã€‚æ“¬ä¼¼ã‚³ãƒ¼ãƒ‰ï¼ˆã»ã¼ Pythonï¼‰ã§ã‚ã‹ã‚Šã‚„ã™ãèª¬æ˜ã•ã‚Œã¦ã„ã‚‹ã®ã§ã“ã‚Œã ã‘è¦‹ã‚Œã° Union Find master! ã¨ã¯ã„ã‹ãšã¨ã‚‚ bachelor ãã‚‰ã„ã«ã¯ãªã‚Œã¦ã„ã‚‹ã¨æ€ã„ã¾ã™ã€‚
https://en.wikipedia.org/wiki/Disjoint-set_data_structure
